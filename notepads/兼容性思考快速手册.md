# 系统的兼容性处理思考

- Beta1是基线版本
- 以基线版本为基础，构造一批Raw Data(这是Beta2版本的首要工作)
- 基于这些Raw Data，用当前版本代码构建测试用例，如果测试用例失败，就说明出现了兼容性问题
- 必须的修改，需要在安装包里做兼容性处理，并永久性留下文档
- 有一些数据格式是协议的一部分（会被别的系统引入），这类数据格式的修改总是要向下兼容

下面列出已知的兼容性数据：

## did-resolve体系

核心的did-document格式设计:

- ZoneBootConfi->ZoneConfig, 简单的说就是已经设置在TXT Record里的记录的兼容性
- DeviceMiniConfig,DeviceConfig,DeviceInfo,DeviceMiniInfo(这个只和激活有关，激活页面同步修改就好)
DeviceConfig和DeviceInfo原则上都可以保存ip地址，这里需要验证是否矛盾，是否能正确处理ipv6
- OwnerConfig
现在的体系，允许did:bns:xxx结构的OwnerConfig完全由SN维护
无SN的节点的OwnerConfig的构造问题？

## Content Network (协议)
基于did-doc + ndn的buckyos 内容发布网络，目前专注于AppMeta

- AppDoc / PackageMeta/ FileObject / BaseContentObject
###  pkg-env 

## ndn_lib
### ndm的数据库结构改变
- ndm数据库的定义是dcfs文件系统。其数据结构升级会严重影响用户的所有数据。要仔细处理
  - ndm接口文件系统化（看看有什么不足），缺PushDir的接口（现在的接口支持能行么）
  - GC的支持：测试
  - 对Content Network的支持是否有问题？
  - 对did-doc的支持

### 标准对象设计 （协议）
- BaseContentObject
- FileObject 
- DirObject / SimpleObjectMap
- PathObject
- Realtion Object
- Action Object

## (d) FileSystem
主要是目录结构的设计不能随意调整。虽然应用是通过sdk接口获得

## system-config / scheduler
常规的覆盖安装的兼容性，由system-config-service的backend保障。一旦跟换backend,就需要走下面的dump->import流程
这里的角度是，从旧版本的system-config dump后，import到新版本的system-config时，如何保持向下兼容
首先，不是所有的数据都值得在dump时保留，尤其是可以通过一次强制调度就构造的数据


## verify-hub
- verify-info 结构

## sys-control-panel

系统配置，全部保存在systemconfig中。无其他数据

## repo-service

对于普通用户来说，保存了自己下载的各种dapp的原始数据（磁盘空间占用的来源）？
这些数据被保存到library中。这些数据原理上只要保存好meta,是可以重新下载的
旧版本的app meta是否可以被当前版本的pkg-env安装，属于Pkg-env的安装问题

对于开发者来说，对外发布的app被保存到repo-service中
- 自己的app 版本发布记录
- 所有版本对应的pkg file object

## klog 
klog对的功能比较单纯，原则上没有修改的必要
一旦修改，类似block chain的tx / block格式修改。需要仔细的从某个块高度开始处理兼容性（或则整体转换）

## slog
作为一个system event收集器，基本没有太大的数据兼容问题

## 非内核服务本身的数据兼容性

这些数据的兼容性与应用程序的兼容性逻辑基本一致。核心就是保存在其data目录的数据格式要保持向下兼容。

### task-manager

### msg_bus


