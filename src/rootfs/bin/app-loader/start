#!/usr/bin/python3

import os
import sys
import json
import platform

current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))
import util
from app_doc import AppDoc, AppDocError

appid = None
full_appid = None
username = None
app_token = None
app_instance_config = None
app_media_info = None
media_info_str = None
zone_config = None
device_info = None

is_support_docker = True
current_dir = os.path.dirname(os.path.abspath(__file__))

def _normalize_digest(digest):
    if not digest:
        return None
    s = str(digest).strip()
    if "@" in s:
        s = s.split("@", 1)[1].strip()
    return s or None


def check_image_exists(image_name, digest=None):
    """
    Check if a docker image exists locally.

    If `digest` is provided, also verify the local image matches the digest.
    Digest can be either:
    - "sha256:..."
    - "<repo>@sha256:..."
    """
    print(f"do check_image_exists: {image_name}, {digest}")
    check_image_cmd = f"docker images -q {image_name}"
    image_id = os.popen(check_image_cmd).read().strip()
    if not image_id:
        return False

    if not digest:
        return True

    target = str(digest).strip()
    if "@" in target:
        target = target.split("@", 1)[1].strip()
    if not target:
        return True

    # First, try to match against RepoDigests (for images pulled from registry)
    # Use different quote styles for Windows vs Linux
    is_windows = platform.system() == "Windows"
    if is_windows:
        inspect_cmd = f'docker image inspect --format="{{{{json .RepoDigests}}}}" {image_name}'
    else:
        inspect_cmd = f"docker image inspect --format='{{{{json .RepoDigests}}}}' {image_name}"
    inspect_out = os.popen(inspect_cmd).read().strip()
    if inspect_out:
        try:
            repo_digests = json.loads(inspect_out)
            if isinstance(repo_digests, list):
                for rd in repo_digests:
                    if not isinstance(rd, str):
                        continue
                    if "@" in rd:
                        local_digest = rd.split("@", 1)[1].strip()
                        if local_digest == target:
                            return True
        except Exception:
            pass

    # If RepoDigests is empty or doesn't match, check the image's actual digest (Id field)
    # This handles images that were locally tagged or loaded from tar
    if is_windows:
        inspect_cmd_id = f'docker image inspect --format="{{{{.Id}}}}" {image_name}'
    else:
        inspect_cmd_id = f"docker image inspect --format='{{{{.Id}}}}' {image_name}"
    inspect_id_out = os.popen(inspect_cmd_id).read().strip()
    if inspect_id_out:
        # Docker Id format is "sha256:xxxxx", same as digest format
        if inspect_id_out == target:
            return True
        # Also try without the algorithm prefix
        if ":" in inspect_id_out and ":" in target:
            id_hash = inspect_id_out.split(":", 1)[1]
            target_hash = target.split(":", 1)[1]
            if id_hash == target_hash:
                return True

    return False


def load_image_from_tar(image_tar_path):
    load_cmd = f"docker load -i {image_tar_path}"
    ret = os.system(load_cmd)
    if ret != 0:
        print(f"Failed to load image from {image_tar_path}")
        exit(1)
    print(f"Successfully loaded image from tar file")
    # 这里并不删除tar文件，而是通过垃圾回收机制删除

def start_app_without_docker():
    print(f"Start app {appid} without docker")
    full_path = app_media_info.get("full_path")
    if not full_path:
        print(f"No app media full path found for appid: {appid}")
        exit(1)
            
    start_script = f"{full_path}/start"
    if not os.path.exists(start_script):
        print(f"No start script found for appid: {appid}")
        exit(1)
    os.system(f"python3 {start_script} {appid} {username}")

def ensure_directory_accessible(directory_path):
    if not os.path.exists(directory_path):
        os.makedirs(directory_path, exist_ok=True)
    os.system(f"chmod -R 777 {directory_path}")
    return directory_path

def start_app_with_docker():
    # 如果镜像已经在运行，则先停止再启动
    global app_media_info
    container_id = full_appid
    print(f"Before start, try stopping container: {container_id}")
    docker_command = f"docker kill {container_id}"
    os.system(docker_command)

    # 得到镜像名（基于 AppDoc 做架构选择）
    try:
        app_doc = AppDoc.from_dict(app_instance_config.get("app_spec", {}).get("app_doc", {}))
        image_desc = app_doc.pkg_list.get_docker_image_for_host(platform.machine())
        image_name = image_desc.docker_image_name
        image_pkg_id = image_desc.pkg_id
        image_digest = image_desc.docker_image_digest
        service_install_tips = app_doc.install_config_tips
    except AppDocError as e:
        print(f"Invalid app_doc in app_instance_config: {e}")
        exit(1)

    if not image_name:
        print("Image name not found in the configuration")
        exit(1)

    if not check_image_exists(image_name, image_digest):
        print(f"Image {image_name} not installed, trying to import docker image from local tar file")
        is_imported = False
        # 如果能import，优先import
        if media_info_str is not None:
            app_media_info = json.loads(media_info_str)
            full_path = app_media_info.get("full_path")
            if not full_path:
                print(f"No app media full path found for appid: {appid}")
                exit(1)
            if not image_pkg_id:
                print(f"No image pkg id found for appid: {appid}")
                exit(1)
            image_tar_path = f"{full_path}/{appid}.tar"
            if os.path.exists(image_tar_path):
                print(f"Try loading docker image from {image_tar_path}")
                load_image_from_tar(image_tar_path)
                is_imported = True

        if not is_imported:
            image_full_name = None
            if zone_docker_repo_base_url:
                image_full_name = f"{zone_docker_repo_base_url}/{image_name}"
            else:
                image_full_name = image_name

            if image_digest:
                digest_only = _normalize_digest(image_digest)
                pull_ref = f"{image_full_name}@{digest_only}"
            else:
                pull_ref = image_full_name

            pull_cmd = f"docker pull {pull_ref}"
            print(f"Try Pulling docker image by {pull_cmd}")
            ret = os.system(pull_cmd)
            if ret != 0:
                print(f"Failed to import docker image {image_name}")
                exit(1)
            # Tag pulled ref back to `image_name` for consistent later run/check.
            if pull_ref != image_name:
                # When pulling by digest, we need to get the image ID and tag it
                # because "docker tag image@digest newname" doesn't work
                get_id_cmd = f"docker images -q {pull_ref.split('@')[0]}"
                pulled_image_id = os.popen(get_id_cmd).read().strip()
                if pulled_image_id:
                    tag_cmd = f"docker tag {pulled_image_id} {image_name}"
                    print(f"Tagging pulled image: {tag_cmd}")
                    os.system(tag_cmd)
                else:
                    # Fallback: try tagging with the full pull_ref (might not work with @digest)
                    os.system(f"docker tag {pull_ref} {image_name}")

        # After import (load or pull), validate again (and verify digest if provided).
        if not check_image_exists(image_name, image_digest):
            print(f"Imported image {image_name} but digest/tag not matched or inspect failed")
            exit(1)
    
    print(f"Image {image_name} exists, now start container ...")

    volume_mapping = ""
    instance_install_config = app_instance_config.get("app_spec").get("install_config")
    data_mount_point = instance_install_config.get("data_mount_point",{})
    if data_mount_point:
        for (folder_in_docker,real_folder_in_host) in data_mount_point.items():
            real_folder_in_host = util.get_buckyos_root() + real_folder_in_host
            #print(f"mount {folder_in_docker} -> {real_folder_in_host}")
            ensure_directory_accessible(real_folder_in_host)
            volume_mapping += f" -v {real_folder_in_host}:{folder_in_docker}"

    cache_mount_point = instance_install_config.get("cache_mount_point", [])
    if cache_mount_point:
        base_cache_dir = util.get_app_cache_dir(appid,username)
        base_cache_dir = ensure_directory_accessible(base_cache_dir)
        for mount_point in cache_mount_point:
            volume_mapping += f" -v {base_cache_dir}/{mount_point}:{mount_point}"

    local_cache_mount_point = instance_install_config.get("local_cache_mount_point", [])
    if local_cache_mount_point:
        base_cache_dir = util.get_app_local_cache_dir(appid,username)
        base_cache_dir = ensure_directory_accessible(base_cache_dir)
        for mount_point in local_cache_mount_point:
            volume_mapping += f" -v {base_cache_dir}/{mount_point}:{mount_point}"

    # 端口映射
    port_cmd = ""
    service_ports = app_instance_config.get("service_ports_config", {})
    #print(f"** service_ports: {service_ports}")
    for (service_name,instance_port) in service_ports.items():
        docker_port = service_install_tips.service_ports.get(service_name, 0)
        if docker_port == 0:
            print(f"No docker port found for service: {service_name}")
            exit(1)
        #print(f"{service_name}: {host_port} -> {docker_port}")
        port_cmd += f" -p {instance_port}:{docker_port} "

    # 构造docker命令
    # 让容器内拿到 zone_config 和当前 app token（使用真实 env key）
    app_token_env_key = util.get_session_token_env_key(full_appid, True)
    docker_command = f"docker run --rm {port_cmd} --name {container_id} -e BUCKYOS_ZONE_CONFIG -e {app_token_env_key} -d "

    if volume_mapping:
        docker_command += volume_mapping

    #if network_settings:
    #    docker_command += f"--network {network_settings} "

    #if cpu_quota:
    #    docker_command += f"--cpu-quota={cpu_quota} "


    container_param = instance_install_config.get("container_param")
    if container_param:
        docker_command += f" {container_param}"

    docker_command += f" {image_name}"

    print(f"* craete container, command: {docker_command}")
    os.system(docker_command)


def start_app():
    global appid, full_appid,username, app_token, app_instance_config,app_media_info,media_info_str
    global zone_config, zone_docker_repo_base_url
    global device_doc, is_support_docker
    
    appid = sys.argv[1]
    username = sys.argv[2]
    full_appid = util.get_full_appid(appid, username)
    app_token_env_key = util.get_session_token_env_key(full_appid, True)
    app_token = os.getenv(app_token_env_key)
    app_instance_config_str = os.getenv("app_instance_config")
    media_info_str = os.getenv("app_media_info")
    zone_config_str = os.getenv(f"BUCKYOS_ZONE_CONFIG")
    zone_config = None
    zone_docker_repo_base_url = None
    device_info_str = os.getenv("BUCKYOS_THIS_DEVICE_INFO")
    device_info = {}
    # 打印所有环境变量用于调试
    # print("=== 环境变量列表（用于调试）===")
    # for key, value in os.environ.items():
    #     print(f"{key}: {value}")
    # print("=== 环境变量列表结束 ===")


    if zone_config_str:
        zone_config = json.loads(zone_config_str)
        docker_repo_base_url = zone_config.get("docker_repo_base_url")
        if docker_repo_base_url:
            zone_docker_repo_base_url = docker_repo_base_url
    
    if device_info_str:
        try:
            device_info = json.loads(device_info_str) or {}
        except Exception:
            device_info = {}

    if app_token is None:
        print(f"No session token found for appid: {full_appid},env_key: {app_token_env_key}")
        exit(1)
        
    if app_instance_config_str is None:
        print(f"No configuration found for appid: {full_appid}")
        exit(1)
    app_instance_config = json.loads(app_instance_config_str)

    #container_hash = app_meta_info.get("image_hash")
    is_support_docker = bool(device_info.get("support_container", True))

    if is_support_docker:
        print(f"Start app {full_appid} with docker")
        start_app_with_docker()
    else:
        if media_info_str is None:
            print(f"No media info found for appid: {full_appid}")
            exit(1)
            
        app_media_info = json.loads(media_info_str)
        print(f"Start app {full_appid} without docker")
        start_app_without_docker()

if __name__ == "__main__":
    start_app()

